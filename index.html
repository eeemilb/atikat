<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Space Lab</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/STLLoader.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; ; overflow: hidden; }
    
    :root { --primary: #ffd700; --dark-bg: #0a0a0a; --dark-card: rgba(30,30,50,0.5); --glass-border: rgba(255,215,0,0.1); }
    .container { display: flex; flex-direction: column; height: 100vh; }
    header { padding: 12px 16px; border-bottom: 1px solid #eee; display: flex; align-items: center; justify-content: space-between; }
    .header-title { font-size: 16px; font-weight: 600; flex: 1; text-align: center; }
    .profile { display: flex; align-items: center; gap: 8px; }
    .avatar { width: 32px; height: 32px; border-radius: 50%; background: ; display: flex; align-items: center; justify-content: center; color: white; font-weight: 600; font-size: 12px; }
    .avatar img { width: 100%; height: 100%; border-radius: 50%; object-fit: cover; }
    .content { flex: 1; overflow-y: auto; padding: 16px; }
    .item { padding: 12px; border: 1px solid #eee; border-radius: 8px; margin-bottom: 8px; cursor: pointer; display: flex; align-items: center; gap: 12px; transition: all 0.2s; }
    .item:hover { background: #f5f5f5; border-color: #ddd; }
    .item-icon { font-size: 20px; min-width: 24px; }
    .item-name { flex: 1; font-size: 14px; font-weight: 500; }
    .item-size { font-size: 12px; color: #999; }
    .empty { text-align: center; padding: 40px 20px; color: #999; }
    .error { background: #fee; padding: 12px; border-radius: 8px; color: #c33; margin: 8px 0; }
    .back-btn { padding: 8px 12px; background: #f0f0f0; border: none; border-radius: 6px; cursor: pointer; margin-bottom: 12px; }
    .viewer { margin-top: 12px; border-radius: 8px; overflow: hidden; max-height: calc(100vh - 200px); ; }
    .viewer img { max-width: 100%; height: auto; border-radius: 8px; display: block; }
    .viewer video, .viewer audio { width: 100%; border-radius: 8px; }
    .viewer iframe { width: 100%; height: 600px; border-radius: 8px; border: none; }
    .viewer pre { background: #f5f5f5; padding: 12px; border-radius: 8px; overflow: auto; font-size: 12px; line-height: 1.5; }
    #canvas3d { width: 100%; height: 500px; border-radius: 8px; background: #f5f5f5; }
    .info-box { padding: 20px; text-align: center; color: #666; }
    .download-btn { color: ; text-decoration: none; border: 1px solid ; padding: 8px 16px; border-radius: 6px; display: inline-block; margin-top: 12px; }
    .controls-hint { padding: 8px; background: #f0f7ff; border-radius: 6px; color: #666; font-size: 12px; margin-top: 8px; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div class="header-title">Space Lab</div>
      <div class="profile">
        <div class="avatar" id="avatar">?</div>
      </div>
    </header>
    <div id="content" class="content">
      <div class="empty">–ó–∞–≥—Ä—É–∑–∫–∞... –ü–æ–¥–æ–∂–¥–∏ –ø–∞—Ä—É —Å–µ–∫—É–Ω–¥</div>
    </div>
  </div>

  <script>
    const SUPABASE_URL = 'https://fdvqlfmnppftzjvocbla.supabase.co';
    const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZkdnFsZm1ucHBmdHpqdm9jYmxhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU1MDEyODAsImV4cCI6MjA4MTA3NzI4MH0.PX9t2L2zgg66JYSqv5nPyzCnZERY3lFEngIte5tIAUI';
    const BUCKET = 'topics';
    let currentPath = '';
    let pathStack = [];
    let viewer3d = null;
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
    const tg = window.Telegram.WebApp;

    async function init() {
      const user = tg.initDataUnsafe?.user;
      if (user) {
        const avatar = document.getElementById('avatar');
        if (user.photo_url) {
          avatar.innerHTML = `<img src="${user.photo_url}" alt="avatar">`;
        } else {
          avatar.textContent = (user.first_name || 'U')[0];
        }
      }
      await loadFolder('');
    }

    async function loadFolder(path) {
      const content = document.getElementById('content');
      content.innerHTML = '<div class="empty">...</div>';
      currentPath = path;
      try {
        const { data, error } = await supabase.storage.from(BUCKET).list(path, { limit: 1000 });
        if (error) throw error;
        
        if (!data || data.length === 0) {
          content.innerHTML = `<div class="empty">–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫. –ù–µ—Ç —Ñ–∞–π–ª–æ–≤ –∏ –ø–∞–ø–æ–∫</div>`;
          return;
        }
        
        const folders = data.filter(item => item.id === null);
        const files = data.filter(item => item.id !== null);
        let html = '';
        
        if (path) {
          html += `<button class="back-btn" onclick="goBack()">‚Üê –ù–∞–∑–∞–¥</button>`;
        }
        
        folders.forEach(folder => {
          html += `<div class="item" onclick="enterFolder('${path ? path + '/' : ''}${folder.name}')">
            <div class="item-icon">üìÅ</div>
            <div class="item-name">${folder.name}</div>
          </div>`;
        });
        
        files.forEach(file => {
          const size = file.metadata?.size ? `${(file.metadata.size / 1024).toFixed(1)} KB` : '';
          html += `<div class="item" onclick="openFile('${path ? path + '/' : ''}${file.name}')">
            <div class="item-icon">üìÑ</div>
            <div>
              <div class="item-name">${file.name}</div>
              ${size ? `<div class="item-size">${size}</div>` : ''}
            </div>
          </div>`;
        });
        
        content.innerHTML = html;
      } catch (e) {
        console.error('Error:', e);
        content.innerHTML = `<div class="error"><strong>–û—à–∏–±–∫–∞:</strong><br>${e.message}</div>`;
      }
    }

    class Viewer3D {
      constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.mesh = null;
      }

      init() {
        if (this.renderer) return;
        const width = this.container.clientWidth;
        const height = 500;
        
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0xf5f5f5);
        this.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 10000);
        this.camera.position.set(0, 0, 100);
        
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(width, height);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.container.innerHTML = '';
        this.container.appendChild(this.renderer.domElement);
        
        const light1 = new THREE.DirectionalLight(0xffffff, 0.8);
        light1.position.set(100, 100, 100);
        this.scene.add(light1);
        
        const light2 = new THREE.DirectionalLight(0xffffff, 0.4);
        light2.position.set(-100, -100, -100);
        this.scene.add(light2);
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        this.scene.add(ambientLight);

        this.setupControls();
        this.animate();
      }

      loadSTL(arrayBuffer) {
        const geometry = this.parseSTL(arrayBuffer);
        geometry.center();
        geometry.computeVertexNormals();
        geometry.computeBoundingBox();
        
        if (this.mesh) {
          this.scene.remove(this.mesh);
        }
        
        const material = new THREE.MeshPhongMaterial({ color: 0x4a90e2, shininess: 100 });
        this.mesh = new THREE.Mesh(geometry, material);
        this.scene.add(this.mesh);
        this.fitCameraToObject();
      }

      parseSTL(arrayBuffer) {
        const view = new DataView(arrayBuffer);
        const isASCII = this.isASCIISTL(arrayBuffer);
        
        if (isASCII) {
          return this.parseASCIISTL(new TextDecoder().decode(arrayBuffer));
        } else {
          return this.parseBinarySTL(arrayBuffer);
        }
      }

      isASCIISTL(arrayBuffer) {
        const view = new Uint8Array(arrayBuffer);
        const header = new TextDecoder().decode(view.slice(0, 5));
        return header === 'solid';
      }

      parseBinarySTL(arrayBuffer) {
        const view = new DataView(arrayBuffer);
        const triangles = view.getUint32(80, true);
        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        const normals = [];
        let offset = 84;
        
        for (let i = 0; i < triangles; i++) {
          const nx = view.getFloat32(offset, true);
          const ny = view.getFloat32(offset + 4, true);
          const nz = view.getFloat32(offset + 8, true);
          offset += 12;
          
          for (let j = 0; j < 3; j++) {
            vertices.push(view.getFloat32(offset, true), view.getFloat32(offset + 4, true), view.getFloat32(offset + 8, true));
            normals.push(nx, ny, nz);
            offset += 12;
          }
          offset += 2;
        }
        
        geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
        geometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(normals), 3));
        return geometry;
      }

      parseASCIISTL(data) {
        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        const normals = [];
        
        const vertexPattern = /vertex\s+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)\s+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)\s+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)/g;
        const normalPattern = /facet\s+normal\s+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)\s+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)\s+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)/g;
        
        let normalMatch;
        let currentNormal = [0, 0, 1];
        while ((normalMatch = normalPattern.exec(data)) !== null) {
          currentNormal = [parseFloat(normalMatch[1]), parseFloat(normalMatch[3]), parseFloat(normalMatch[5])];
        }
        
        let vertexMatch;
        while ((vertexMatch = vertexPattern.exec(data)) !== null) {
          vertices.push(parseFloat(vertexMatch[1]), parseFloat(vertexMatch[3]), parseFloat(vertexMatch[5]));
          normals.push(currentNormal[0], currentNormal[1], currentNormal[2]);
        }
        
        geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
        geometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(normals), 3));
        return geometry;
      }

      fitCameraToObject() {
        const bbox = this.mesh.geometry.boundingBox;
        const size = bbox.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        const fov = this.camera.fov * (Math.PI / 180);
        let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
        cameraZ *= 1.5;
        this.camera.position.z = cameraZ;
      }

      setupControls() { let isDragging = false; let previousMousePosition = { x: 0, y: 0 }; this.renderer.domElement.addEventListener('mousedown', (e) => { isDragging = true; previousMousePosition = { x: e.clientX, y: e.clientY }; }); this.renderer.domElement.addEventListener('mousemove', (e) => { if (isDragging && this.mesh) { const deltaX = e.clientX - previousMousePosition.x; const deltaY = e.clientY - previousMousePosition.y; this.mesh.rotation.y += deltaX * 0.01; this.mesh.rotation.x += deltaY * 0.01; previousMousePosition = { x: e.clientX, y: e.clientY }; } }); this.renderer.domElement.addEventListener('mouseup', () => { isDragging = false; }); this.renderer.domElement.addEventListener('wheel', (e) => { e.preventDefault(); const zoomSpeed = 1.1; if (e.deltaY > 0) { this.camera.position.z *= zoomSpeed; } else { this.camera.position.z /= zoomSpeed; } }, false); let touchStart = { x: 0, y: 0 }; let lastDistance = 0; this.renderer.domElement.addEventListener('touchstart', (e) => { if (e.touches.length === 1) { touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY }; } else if (e.touches.length === 2) { const dx = e.touches[0].clientX - e.touches[1].clientX; const dy = e.touches[0].clientY - e.touches[1].clientY; lastDistance = Math.sqrt(dx * dx + dy * dy); } }); this.renderer.domElement.addEventListener('touchmove', (e) => { e.preventDefault(); if (e.touches.length === 1 && this.mesh) { const deltaX = e.touches[0].clientX - touchStart.x; const deltaY = e.touches[0].clientY - touchStart.y; this.mesh.rotation.y += deltaX * 0.01; this.mesh.rotation.x += deltaY * 0.01; touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY }; } else if (e.touches.length === 2) { const dx = e.touches[0].clientX - e.touches[1].clientX; const dy = e.touches[0].clientY - e.touches[1].clientY; const distance = Math.sqrt(dx * dx + dy * dy); if (lastDistance > 0) { const zoom = distance / lastDistance; this.camera.position.z /= zoom; } lastDistance = distance; } }); }

      animate() {
        requestAnimationFrame(() => this.animate());
        this.renderer.render(this.scene, this.camera);
      }
    }

    async function openFile(filePath) {
      const content = document.getElementById('content');
      content.innerHTML = '<div class="empty"> —Ñ–∞–π–ª–∞...</div>';
      
      try {
        const fileName = filePath.split('/').pop();
        const ext = fileName.split('.').pop().toLowerCase();
        const url = supabase.storage.from(BUCKET).getPublicUrl(filePath).data.publicUrl;
        
        let html = `<button class="back-btn" onclick="loadFolder('${currentPath}')">‚Üê –ù–∞–∑–∞–¥</button>`;
        
        if (['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp'].includes(ext)) {
          html += `<div class="viewer"><img src="${url}" alt="–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ"></div>`;
        } else if (['mp4', 'avi', 'mov', 'mkv', 'webm'].includes(ext)) {
          html += `<div class="viewer"><video controls><source src="${url}"></video></div>`;
        } else if (['mp3', 'wav', 'flac', 'm4a'].includes(ext)) {
          html += `<div class="viewer"><audio controls style="width: 100%;"><source src="${url}"></audio></div>`;
        } else if (ext === 'pdf') {
          html += `<div class="viewer"><iframe src="${url}"></iframe></div>`;
        } else if (ext === 'html') {
          html += `<div class="viewer"><iframe id="html-viewer" style="width: 100%; height: 600px; border: none;"></iframe></div>`;
          content.innerHTML = html;
          setTimeout(async () => {
            const {data: fileData} = await supabase.storage.from(BUCKET).download(filePath);
            const text = await fileData.text();
            document.getElementById('html-viewer').srcdoc = text;
          }, 100);
          return;
        } else if (['stl', 'obj', 'gltf', 'glb'].includes(ext)) {
          html += `<div id="viewer3d" class="viewer"></div><div class="controls-hint">üóëÔ∏è –í—Ä–∞—â–µ–Ω–∏–µ: –ø–µ—Ä–µ—Ç—è–≥–∏–≤–∞–Ω–∏–µ –º—ã—à–∫–æ–π –∏–ª–∏ –ø–∞–ª—å—Ü–µ–º | üîç –ú–∞—Å—à—Ç–∞–±: —Å–∫—Ä–æ–ª–ª –º—ã—à–∫–∏ –∏–ª–∏ –¥–≤–∞ –ø–∞–ª—å—Ü–∞</div>`;
          content.innerHTML = html;
          viewer3d = new Viewer3D('viewer3d');
          viewer3d.init();
          const {data: fileData} = await supabase.storage.from(BUCKET).download(filePath);
          const arrayBuffer = await fileData.arrayBuffer();
          viewer3d.loadSTL(arrayBuffer);
          return;
        } else {
          const { data: fileData } = await supabase.storage.from(BUCKET).download(filePath);
          const text = await fileData.text();
          html += `<div class="viewer"><pre>${text.substring(0, 10000)}</pre></div>`;
        }
        
        content.innerHTML = html;
      } catch (e) {
        console.error('Error:', e);
        content.innerHTML = `<button class="back-btn" onclick="loadFolder('${currentPath}')">‚Üê –ù–∞–∑–∞–¥</button><div class="error">–û—à–∏–±–∫–∞: ${e.message}</div>`;
      }
    }

    function enterFolder(path) {
      pathStack.push(currentPath);
      loadFolder(path);
    }

    function goBack() {
      if (pathStack.length > 0) {
        const previousPath = pathStack.pop();
        loadFolder(previousPath);
      }
    }

    function initTheme() {
        tg.setHeaderColor('#ffffff');
      }

    function initProfileMenu() {
        // Initialize profile menu
      }
    // –ó–∞–ø—É—Å–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
    initTheme(); initProfileMenu();
    document.getElementById('content').innerHTML = '<div class="empty">–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è...</div>';
    init().catch(err => console.error('Init failed:', err));
    loadFolder('').catch(err => console.error('Load failed:', err));
  </script>
</body>
</html>
